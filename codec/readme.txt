什麼是粘包

一個完成的消息可能會被TCP拆分成多個包進行發送，也有可能把多個小的包封裝成一個大的數據包發送，這個就是TCP的拆包和封包問題

TCP粘包和拆包產生的原因

應用程序寫入數據的位元組大小大於套接字發送緩衝區的大小

進行MSS大小的TCP分段。MSS是最大報文段長度的縮寫。MSS是TCP報文段中的數據欄位的最大長度。數據欄位加上TCP首部才等於整個的TCP報文段。所以MSS並不是TCP報文段的最大長度，而是：MSS=TCP報文段長度-TCP首部長度

乙太網的payload大於MTU進行IP分片。MTU指：一種通信協議的某一層上面所能通過的最大數據包大小。如果IP層有一個數據包要傳，而且數據的長度比鏈路層的MTU大，那麼IP層就會進行分片，把數據包分成托乾片，讓每一片都不超過MTU。注意，IP分片可以發生在原始發送端主機上，也可以發生在中間路由器上。

TCP粘包和拆包的解決策略

消息定長。例如100位元組。
在包尾部增加回車或者空格符等特殊字元進行分割，典型的如FTP協議
將消息分為消息頭和消息尾。
其它複雜的協議，如RTMP協議等。
參考(http://blog.csdn.net/initphp/article/details/41948919)

我們的處理方式

解決粘包問題有多種多樣的方式, 我們這裡的做法是:

發送方在每次發送消息時將消息長度寫入一個int32作為包頭一併發送出去, 我們稱之為Encode
接受方則先讀取一個int32的長度的消息長度信息, 再根據長度讀取相應長的byte數據, 稱之為Decode